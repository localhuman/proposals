<pre>
  NEP: <to be assigned>
  Title: Dynamic Contract Invocation
  Author: localhuman, unignorant
  Type: Standard
  Status: Draft
  Created: 2017-11-06
</pre>

==Abstract==

This NEP Proposal outlines a mechanism whereby a Smart Contract is provided the ability to invoke other Smart Contracts not known until runtime, rather than being limited to invoking only Smart Contracts that are defined at compile time. In order to retain the ability for Smart Contracts to interface with a future Dynamic Sharding process, included is a proposed specification to be used in the creation of Smart Contracts to denote whether a Smart Contract needs the Dynamic Contract Invocation feature or not.

==Motivation==

The motivation for this NEP is to give smart contract (SC) authors the ability to interface with SCs that are not known at compile time. For example, a SC that operates a decentralized exchange of NEP-5 tokens might call the <code>transferFrom</code> method of a token SC determined at runtime. At present, such a SC would need to hard-code all supported NEP-5 token addresses and be re-published whenever a new token is added. Many other popular smart contracts on Ethereum require this feature [X, Y, Z, W]. Given the ability to determine at runtime the SC it wants to interface, these examples would be much easier to develop and maintain.

It is important to note that adding dynamic SC calls to NEO affects scalability. With dynamic SC calls, we no longer know in advance what other SCs will be called, and so what subset of VM state must be available for execution to succeed. This makes dynamic sharding more difficult to implement. 
  
To overcome the scalability drawback, this proposal adds a specification to each SC when it is created on the blockchain to denote whether it will need the dynamic calling feature or not. This specification will allow all existing contracts and the majority of future contracts to be executed in a storage context that is known in advance and thus more amenable to dynamic sharding, while also making SCs much more powerful and expressive.  


==Specification==

This proposal outlines changes in 3 general areas of the Neo project, and provides a sample for how this change could be used in a SC:

* neo
* neo-vm
* neo-compiler
* sample smart contract

The changes listed below do not attempt to be exhaustive, but rather give a general overview of important changes needed in each library.

====neo====

In order for a SC to denote whether it has the ability to dynamically invoke other SCs, this NEP advises to add the following property to <code>neo.Core.ContractState</code> object, which would default to <code>false</code>.

<pre>
        public bool HasDynamicInvoke
</pre>

In order to keep the implentation interoperable with the current Neo protocol, The <code>HasDynamicInvoke</code> property would be serialized as a byte flag along with the current <code>HasStorage</code> property:

<pre>

    [Flags]
    public enum ContractPropertyState : byte
    {
        NoProperty = 0,
        HasStorage = 1 << 0,
        HasDynamicInvoke = 1 << 1,
    }



    public class ContractState : StateBase, ICloneable<ContractState>
    {

        ...

        public ContractPropertyState ContractProperties;

        public bool HasStorage => ContractProperties.HasFlag(ContractPropertyState.HasStorage)

        public bool HasDynamicInvoke => ContractProperties.HasFlag(ContractPropertyState.HasDynamicInvoke)

        ...

        public override void Serialize(BinaryWriter writer)
        {
            base.Serialize(writer);
            writer.WriteVarBytes(Script);
            writer.WriteVarBytes(ParameterList.Cast<byte>().ToArray());
            writer.Write((byte)ReturnType);
            writer.Write(ContractProperties);   // currently is writer.Write(HasStorage)
            writer.WriteVarString(Name);
            writer.WriteVarString(CodeVersion);
            writer.WriteVarString(Author);
            writer.WriteVarString(Email);
            writer.WriteVarString(Description);
        }
</pre>


====neo-vm====

This specification proposes that a new OpCode be added to the Neo Virtual Machine to denote the usage of a ''dynamic'' <code>AppCall</code> versus a ''static'' one.

<pre>
        DYNAMICCALL = 0xFA
</pre>

The execution of the <code>DYNAMICCALL</code> OpCode in <code>neo.VM.ExecutionEngine.ExecuteOp</code> method will also differ from the execution of the current <code>APPCALL</code> and <code>TAILCALL</code> OpCodes in the following way:

<pre>
                case OpCode.APPCALL:
                case OpCode.TAILCALL:
                case OpCode.DYNAMICCALL:
                    {
                        if (table == null)
                        {
                            State |= VMState.FAULT;
                            return;
                        }

                        byte[] script_hash = null;

                        if ( opcode == OpCode.DYNAMICCALL ) {

                            script_hash = EvaluationStack.Pop().GetByteArray();

                        } else {

                            script_hash = context.OpReader.ReadBytes(20);
                        }

                        byte[] script = table.GetScript(script_hash);
                        if (script == null)
                        {
                            State |= VMState.FAULT;
                            return;
                        }
                        if (opcode == OpCode.TAILCALL || opcode == OpCode.DYNAMICCALL)
                            InvocationStack.Pop().Dispose();
                        LoadScript(script);
                    }
                    break;
</pre>


====neo-compiler====

A sample method to be used in order to convert a method call to a <code>DYNAMICCALL</code> could look like the following:

<pre>
            else if (calltype == CallType.DYNAMICCALL)
            {
                _ConvertPush(callhash, null, to)
                _Convert1by1(VM.OpCode.DYNAMICCALL, null, to);

            }
</pre>


====sample smart contract====

<pre>

using Neo.SmartContract.Framework.Services.Neo;

namespace Neo.SmartContract
{
    public class DynamicTotalSupply : Framework.SmartContract
    {
        public static int Main(byte[] contract_hash)
        {
        
            if( contract_hash.Length == 20 ) {
            
                BigInteger totalSupply = DynamicCall( contract_hash, 'totalSupply')
            
                return totalSupply;
            }
            
            return 0;
        }
    }
}
</pre>

==Rationale==

Dynamic sharding is not impossible with dynamic SC calls (Ethereum has proposed many solutions [X]), and sharding would have still been challenging without them. Just because we know the compuatation call graph in advance, that does not mean we would be able to successfully shard resources into perfect, non-overlapping subsets. Likely, communication between shards would still need to be implemented, as in the Ethereum proposals.

With this in mind, it may be possible to implement dynamic app calls without adding any meta-data to the Smart Contract about whether it needs dynamic calls or not, given the idea that both could be executed and scaled in the same manner.  

Even if in the case, however, that a system could be implemented to allow for both dynamic SC calls and dynamic sharding, this proposal argues that storing the <code>HasDynamicInvoke</code> property would most likely be useful in that implementation.

Storing this property would also allow the system to charge a different fee for publishing contracts with the <code>HasDynamicInvoke</code> property.


==Backwards Compatibility==

This NEP would introduce a new set of functionality that would not be available to existing Smart Contracts without affecting existing Smart Contracts.  By utilizing the existing byte being used to indicate whether a Smart Contract needs storage or not and adding an additional flag, we are able to retain the current functionality and add to it if necessary without affecting the network protocol.

==Test Cases==

No test cases at this time.

==Implementation==

No implementation at this time.
